// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: groups.sql

package generated

import (
	"context"
	"time"
)

const createGroup = `-- name: CreateGroup :one
INSERT INTO groups (display_name, state, color_theme) VALUES (?, ?, ?)
    RETURNING id, display_name, state, color_theme, created_at, updated_at
`

type CreateGroupParams struct {
	DisplayName string `json:"display_name"`
	State       string `json:"state"`
	ColorTheme  string `json:"color_theme"`
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup, arg.DisplayName, arg.State, arg.ColorTheme)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.State,
		&i.ColorTheme,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGroupById = `-- name: GetGroupById :one
SELECT groups.id as id, groups.display_name as group_name, groups.state as group_state, groups.color_theme as group_theme, groups.created_at as created_at, groups.updated_at as updated_at, group_members.role as member_role FROM groups
    INNER JOIN group_members
        ON group_members.group_id=groups.id
    WHERE groups.id=? AND group_members.user_id=?
`

type GetGroupByIdParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

type GetGroupByIdRow struct {
	ID         int64     `json:"id"`
	GroupName  string    `json:"group_name"`
	GroupState string    `json:"group_state"`
	GroupTheme string    `json:"group_theme"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
	MemberRole string    `json:"member_role"`
}

func (q *Queries) GetGroupById(ctx context.Context, arg GetGroupByIdParams) (GetGroupByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupById, arg.ID, arg.UserID)
	var i GetGroupByIdRow
	err := row.Scan(
		&i.ID,
		&i.GroupName,
		&i.GroupState,
		&i.GroupTheme,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MemberRole,
	)
	return i, err
}

const getGroupsByUserId = `-- name: GetGroupsByUserId :many
SELECT groups.id as id, groups.display_name as group_name, groups.state as group_state, groups.color_theme as group_theme, groups.created_at as created_at, groups.updated_at as updated_at FROM groups
    INNER JOIN group_members
        ON group_members.group_id=groups.id
    WHERE group_members.user_id=?
    ORDER BY group_members.created_at DESC
`

type GetGroupsByUserIdRow struct {
	ID         int64     `json:"id"`
	GroupName  string    `json:"group_name"`
	GroupState string    `json:"group_state"`
	GroupTheme string    `json:"group_theme"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
}

func (q *Queries) GetGroupsByUserId(ctx context.Context, userID int64) ([]GetGroupsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupsByUserIdRow{}
	for rows.Next() {
		var i GetGroupsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupName,
			&i.GroupState,
			&i.GroupTheme,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertGroupMember = `-- name: UpsertGroupMember :exec
INSERT INTO group_members (group_id, user_id, state, role) VALUES (?, ?, ?, ?)
    ON CONFLICT (group_id, user_id)
        DO UPDATE SET state=excluded.state, role=excluded.state, updated_at=excluded.state
`

type UpsertGroupMemberParams struct {
	GroupID int64  `json:"group_id"`
	UserID  int64  `json:"user_id"`
	State   string `json:"state"`
	Role    string `json:"role"`
}

func (q *Queries) UpsertGroupMember(ctx context.Context, arg UpsertGroupMemberParams) error {
	_, err := q.db.ExecContext(ctx, upsertGroupMember,
		arg.GroupID,
		arg.UserID,
		arg.State,
		arg.Role,
	)
	return err
}
