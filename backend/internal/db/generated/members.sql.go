// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: members.sql

package generated

import (
	"context"
)

const deleteGroupMember = `-- name: DeleteGroupMember :exec
DELETE FROM group_members
    WHERE group_id=? AND user_id=?
`

type DeleteGroupMemberParams struct {
	GroupID int64 `json:"group_id"`
	UserID  int64 `json:"user_id"`
}

func (q *Queries) DeleteGroupMember(ctx context.Context, arg DeleteGroupMemberParams) error {
	_, err := q.db.ExecContext(ctx, deleteGroupMember, arg.GroupID, arg.UserID)
	return err
}

const getGroupMember = `-- name: GetGroupMember :one
SELECT group_id, user_id, state AS member_state, role AS member_role FROM group_members
    WHERE group_id=? AND user_id=?
    LIMIT 1
`

type GetGroupMemberParams struct {
	GroupID int64 `json:"group_id"`
	UserID  int64 `json:"user_id"`
}

type GetGroupMemberRow struct {
	GroupID     int64  `json:"group_id"`
	UserID      int64  `json:"user_id"`
	MemberState string `json:"member_state"`
	MemberRole  string `json:"member_role"`
}

func (q *Queries) GetGroupMember(ctx context.Context, arg GetGroupMemberParams) (GetGroupMemberRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupMember, arg.GroupID, arg.UserID)
	var i GetGroupMemberRow
	err := row.Scan(
		&i.GroupID,
		&i.UserID,
		&i.MemberState,
		&i.MemberRole,
	)
	return i, err
}

const getGroupMemberInfoForUser = `-- name: GetGroupMemberInfoForUser :one
SELECT
    users.first_name AS first_name, 
    users.last_name AS last_name,  
    group_members.role AS member_role,
    group_members.state AS member_state,
    users.id AS member_id
    FROM group_members
    INNER JOIN users
        ON users.id=group_members.user_id
    WHERE 
        group_members.group_id=?1
    AND group_members.user_id=?2
`

type GetGroupMemberInfoForUserParams struct {
	GroupID int64 `json:"group_id"`
	UserID  int64 `json:"user_id"`
}

type GetGroupMemberInfoForUserRow struct {
	FirstName   string `json:"first_name"`
	LastName    string `json:"last_name"`
	MemberRole  string `json:"member_role"`
	MemberState string `json:"member_state"`
	MemberID    int64  `json:"member_id"`
}

func (q *Queries) GetGroupMemberInfoForUser(ctx context.Context, arg GetGroupMemberInfoForUserParams) (GetGroupMemberInfoForUserRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupMemberInfoForUser, arg.GroupID, arg.UserID)
	var i GetGroupMemberInfoForUserRow
	err := row.Scan(
		&i.FirstName,
		&i.LastName,
		&i.MemberRole,
		&i.MemberState,
		&i.MemberID,
	)
	return i, err
}

const getGroupMemberTotals = `-- name: GetGroupMemberTotals :many
SELECT user_id, (
        SELECT IFNULL(SUM(group_expenses.cost), 0.0)
        FROM group_expenses
        WHERE group_expenses.group_id = group_members.group_id 
            AND group_expenses.user_id=group_members.user_id
    ) as total,
    group_members.role AS role,
    group_members.state AS state
    FROM group_members
    WHERE group_members.group_id=?
`

type GetGroupMemberTotalsRow struct {
	UserID int64       `json:"user_id"`
	Total  interface{} `json:"total"`
	Role   string      `json:"role"`
	State  string      `json:"state"`
}

func (q *Queries) GetGroupMemberTotals(ctx context.Context, groupID int64) ([]GetGroupMemberTotalsRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupMemberTotals, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupMemberTotalsRow{}
	for rows.Next() {
		var i GetGroupMemberTotalsRow
		if err := rows.Scan(
			&i.UserID,
			&i.Total,
			&i.Role,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupMembersForUser = `-- name: GetGroupMembersForUser :many
SELECT 
    users.first_name AS first_name, 
    users.last_name AS last_name,  
    group_members.role AS member_role,
    group_members.state AS member_state,
    users.id AS member_id
    FROM group_members
    INNER JOIN users
        ON users.id=group_members.user_id
    WHERE 
        group_members.group_id=?
    AND EXISTS (
        SELECT 1
        FROM group_members group_members_check
        WHERE group_members_check.group_id=group_members.group_id
        AND group_members_check.user_id=?
    )
`

type GetGroupMembersForUserParams struct {
	GroupID int64 `json:"group_id"`
	UserID  int64 `json:"user_id"`
}

type GetGroupMembersForUserRow struct {
	FirstName   string `json:"first_name"`
	LastName    string `json:"last_name"`
	MemberRole  string `json:"member_role"`
	MemberState string `json:"member_state"`
	MemberID    int64  `json:"member_id"`
}

func (q *Queries) GetGroupMembersForUser(ctx context.Context, arg GetGroupMembersForUserParams) ([]GetGroupMembersForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupMembersForUser, arg.GroupID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupMembersForUserRow{}
	for rows.Next() {
		var i GetGroupMembersForUserRow
		if err := rows.Scan(
			&i.FirstName,
			&i.LastName,
			&i.MemberRole,
			&i.MemberState,
			&i.MemberID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGroupMemberState = `-- name: UpdateGroupMemberState :exec
UPDATE group_members
    SET
        state=?1,
        updated_at=CURRENT_TIMESTAMP
    WHERE
        user_id=?2 AND
        group_id=?3
`

type UpdateGroupMemberStateParams struct {
	MemberState string `json:"member_state"`
	UserID      int64  `json:"user_id"`
	GroupID     int64  `json:"group_id"`
}

func (q *Queries) UpdateGroupMemberState(ctx context.Context, arg UpdateGroupMemberStateParams) error {
	_, err := q.db.ExecContext(ctx, updateGroupMemberState, arg.MemberState, arg.UserID, arg.GroupID)
	return err
}

const upsertGroupMember = `-- name: UpsertGroupMember :exec
INSERT INTO group_members (group_id, user_id, state, role) VALUES (?, ?, ?, ?)
    ON CONFLICT (group_id, user_id)
        DO UPDATE 
            SET 
                state=excluded.state,
                role=excluded.role,
                updated_at=CURRENT_TIMESTAMP
`

type UpsertGroupMemberParams struct {
	GroupID int64  `json:"group_id"`
	UserID  int64  `json:"user_id"`
	State   string `json:"state"`
	Role    string `json:"role"`
}

func (q *Queries) UpsertGroupMember(ctx context.Context, arg UpsertGroupMemberParams) error {
	_, err := q.db.ExecContext(ctx, upsertGroupMember,
		arg.GroupID,
		arg.UserID,
		arg.State,
		arg.Role,
	)
	return err
}
