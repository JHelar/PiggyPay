// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: groups.sql

package generated

import (
	"context"
	"time"
)

const createGroup = `-- name: CreateGroup :one
INSERT INTO groups (display_name, state, color_theme) VALUES (?, ?, ?)
    RETURNING id, display_name, state, color_theme, created_at, updated_at
`

type CreateGroupParams struct {
	DisplayName string `json:"display_name"`
	State       string `json:"state"`
	ColorTheme  string `json:"color_theme"`
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup, arg.DisplayName, arg.State, arg.ColorTheme)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.State,
		&i.ColorTheme,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGroupById = `-- name: DeleteGroupById :exec
DELETE FROM groups
    WHERE id=(
        SELECT groups.id
        FROM groups
        INNER JOIN group_members
            ON groups.id=group_members.group_id
        WHERE groups.id=? AND group_members.role=? AND group_members.user_id=?
        LIMIT 1
    )
`

type DeleteGroupByIdParams struct {
	ID     int64  `json:"id"`
	Role   string `json:"role"`
	UserID int64  `json:"user_id"`
}

func (q *Queries) DeleteGroupById(ctx context.Context, arg DeleteGroupByIdParams) error {
	_, err := q.db.ExecContext(ctx, deleteGroupById, arg.ID, arg.Role, arg.UserID)
	return err
}

const getGroupForUserById = `-- name: GetGroupForUserById :one
SELECT groups.id AS id,
    groups.display_name AS group_name,
    groups.state AS group_state,
    groups.color_theme AS group_theme,
    groups.created_at AS created_at,
    groups.updated_at AS updated_at,
    group_members.role AS member_role,
    (
        SELECT IFNULL(SUM(group_expenses.cost), 0.0)
        FROM group_expenses
        WHERE group_expenses.group_id = groups.id
    ) AS total_expenses
    FROM groups
    INNER JOIN group_members
        ON group_members.group_id=groups.id
    WHERE groups.id=? AND group_members.user_id=?
    LIMIT 1
`

type GetGroupForUserByIdParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

type GetGroupForUserByIdRow struct {
	ID            int64       `json:"id"`
	GroupName     string      `json:"group_name"`
	GroupState    string      `json:"group_state"`
	GroupTheme    string      `json:"group_theme"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	MemberRole    string      `json:"member_role"`
	TotalExpenses interface{} `json:"total_expenses"`
}

func (q *Queries) GetGroupForUserById(ctx context.Context, arg GetGroupForUserByIdParams) (GetGroupForUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupForUserById, arg.ID, arg.UserID)
	var i GetGroupForUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.GroupName,
		&i.GroupState,
		&i.GroupTheme,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MemberRole,
		&i.TotalExpenses,
	)
	return i, err
}

const getGroupsByUserId = `-- name: GetGroupsByUserId :many
SELECT groups.id AS id,
    groups.display_name AS group_name,
    groups.state AS group_state,
    groups.color_theme AS group_theme,
    groups.created_at AS created_at,
    groups.updated_at AS updated_at,
    (
        SELECT IFNULL(SUM(group_expenses.cost), 0.0)
        FROM group_expenses
        WHERE group_expenses.group_id = groups.id
    ) AS total_expenses
    FROM groups
    INNER JOIN group_members
        ON group_members.group_id=groups.id
    WHERE group_members.user_id=?
    ORDER BY group_members.created_at DESC
`

type GetGroupsByUserIdRow struct {
	ID            int64       `json:"id"`
	GroupName     string      `json:"group_name"`
	GroupState    string      `json:"group_state"`
	GroupTheme    string      `json:"group_theme"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	TotalExpenses interface{} `json:"total_expenses"`
}

func (q *Queries) GetGroupsByUserId(ctx context.Context, userID int64) ([]GetGroupsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupsByUserIdRow{}
	for rows.Next() {
		var i GetGroupsByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupName,
			&i.GroupState,
			&i.GroupTheme,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalExpenses,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGroupById = `-- name: UpdateGroupById :one
UPDATE groups
    SET 
        display_name=?,
        color_theme=?,
        updated_at=CURRENT_TIMESTAMP
    WHERE id = (
        SELECT groups.id
        FROM groups
        INNER JOIN group_members 
            ON group_members.group_id=groups.id
        WHERE groups.id=? AND group_members.user_id=?
    )
    RETURNING id, display_name as group_name, state, color_theme as group_theme, created_at, updated_at
`

type UpdateGroupByIdParams struct {
	DisplayName string `json:"display_name"`
	ColorTheme  string `json:"color_theme"`
	ID          int64  `json:"id"`
	UserID      int64  `json:"user_id"`
}

func (q *Queries) UpdateGroupById(ctx context.Context, arg UpdateGroupByIdParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, updateGroupById,
		arg.DisplayName,
		arg.ColorTheme,
		arg.ID,
		arg.UserID,
	)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.State,
		&i.ColorTheme,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGroupState = `-- name: UpdateGroupState :exec
UPDATE groups
    SET
        state=?,
        updated_at=CURRENT_TIMESTAMP
    WHERE id = (
        SELECT groups.id
        FROM groups
        INNER JOIN group_members 
            ON group_members.group_id=groups.id
        WHERE groups.id=? AND group_members.user_id=?
    )
`

type UpdateGroupStateParams struct {
	State  string `json:"state"`
	ID     int64  `json:"id"`
	UserID int64  `json:"user_id"`
}

func (q *Queries) UpdateGroupState(ctx context.Context, arg UpdateGroupStateParams) error {
	_, err := q.db.ExecContext(ctx, updateGroupState, arg.State, arg.ID, arg.UserID)
	return err
}

const updateGroupStateIfMembersIsInState = `-- name: UpdateGroupStateIfMembersIsInState :exec
UPDATE groups
SET state = ?1, updated_at = CURRENT_TIMESTAMP
WHERE id = ?2 AND groups.state = ?3
    AND (
        SELECT COUNT(*) = SUM(group_members.state = ?4)
        FROM group_members
        WHERE group_id=groups.id
    )
`

type UpdateGroupStateIfMembersIsInStateParams struct {
	ToGroupState     string `json:"to_group_state"`
	GroupID          int64  `json:"group_id"`
	CheckGroupState  string `json:"check_group_state"`
	CheckMemberState string `json:"check_member_state"`
}

func (q *Queries) UpdateGroupStateIfMembersIsInState(ctx context.Context, arg UpdateGroupStateIfMembersIsInStateParams) error {
	_, err := q.db.ExecContext(ctx, updateGroupStateIfMembersIsInState,
		arg.ToGroupState,
		arg.GroupID,
		arg.CheckGroupState,
		arg.CheckMemberState,
	)
	return err
}
